# -*- coding: utf-8 -*-
"""DataVisualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xIFOhCMEcJByfT0rnTk3Uklv7wcdz_nz
"""

import pandas as pd          # For data handling
import numpy as np           # For numerical operations
import matplotlib.pyplot as plt  # For static visualizations
import seaborn as sns        # For advanced plots (like correlation heatmaps)
import plotly.express as px  # For interactive visualizations

import zipfile               # For unzipping files
import os                    # For file path operations
import io                    # For reading files from zip
import warnings              # To suppress warnings
from google.colab import drive

# Load the CSV using pandas
drive.mount('/content/drive')

df = pd.read_csv("/content/Dataset cleaned_ids2018_sampled.csv")

# Check column names
df.columns

num_records = len(df)
print(f"Total number of records: {num_records}")
# Show first few rows to confirm it's loaded
df.head()

from google.colab import drive
drive.mount('/content/drive')

# 2. Identify the first column (it’s currently unnamed)
first_col = df.columns[0]
print("Original first column name:", first_col)

# 3. Rename it to 'FlowID'
df = df.rename(columns={ first_col: 'FlowID' })

# 4. Verify the change
print(df.columns.tolist()[:10])  # shows first 10 column names
print(df['FlowID'].head())

# Show first few rows to confirm it's loaded
df.head()

#Check dataset shape and types
df.shape  # rows and columns
df.info()  # data types and nulls

#Missing values check, 0 = no missing values and 1 = missing value
df.isnull().sum()

#Check how many rows have missing data
df.isnull().any(axis=1).sum()

#Drop the row since 1 row has negligible effect on a dataset with over a million rows.
df = df.dropna()

#This was to verify if the empty row was dropped
df.isnull().any(axis=1).sum()

#applied a mapping to translate the numerical labels in the 'Label' column to their corresponding attack types
label_map = {
    1.0: "Benign",
    2.0: "DoS Hulk",
    3.0: "PortScan",
    4.0: "DDoS",
    5.0: "DoS GoldenEye",
    6.0: "FTP-Patator",
    7.0: "SSH-Patator",
    8.0: "Web Attack – Brute Force",
    9.0: "Web Attack – XSS",
    10.0: "Infiltration",
    11.0: "Bot"
}

df["Attack Type"] = df["Label"].map(label_map)

# Create a summary table with Label Code, Attack Type, and Count
label_counts = df["Label"].value_counts().sort_index()
label_df = pd.DataFrame({
    "Label Code": label_counts.index,
    "Attack Type": [label_map[label] for label in label_counts.index],
    "Count": label_counts.values
})

print(label_df)

# Total flows
total_flows = len(df)

# Benign flows
benign_flows = df[df['Label'] == 1].shape[0]

import matplotlib.pyplot as plt

# Other (non-benign) flows
non_benign_flows = total_flows - benign_flows

# Percentage
benign_percentage = (benign_flows / total_flows) * 100
non_benign_percentage = (non_benign_flows / total_flows) * 100

labels = ['Benign', 'Other']
sizes = [benign_percentage, non_benign_percentage]
colors = sns.xkcd_palette(['windows blue', 'amber'])

plt.pie(sizes, labels=labels, autopct='%1.1f%%', colors=colors, startangle=140)
plt.title("Traffic Distribution: Benign vs Other")
plt.axis('equal')  # Equal aspect ratio ensures pie is drawn as a circle.
plt.show()

"""Question 1: How is the dataset split between benign and attack traffic?

We begin by examining the general composition of traffic in our dataset.

Chart: Pie Chart – Benign vs. Malicious **Traffic**

Insight: This gives us a quick snapshot of dataset balance, revealing whether malicious traffic dominates, or if we're dealing with a subtle threat landscape.
"""

#bar graph was plotted to show distribution of attack types
plt.figure(figsize=(12, 6))
sns.countplot(
    data=df,
    y="Attack Type",
    order=df["Attack Type"].value_counts().index,
    palette="viridis",
    hue="Attack Type",
    legend=False  # Hide redundant legend
)
plt.title("Distribution of Attack Types", fontsize=16)
plt.xlabel("Number of Records")
plt.ylabel("Attack Type")
plt.grid(axis="x", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.show()

"""Question 2: What Types of Attacks Are We Dealing With?

We dive into the types of attacks observed to understand threat diversity.

Chart: Bar Chart – Distribution of Attack Types

Insight: Highlights which threats are most prevalent, guiding where to focus mitigation strategies.

---
"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd

# Apply log1p transform to Flow Duration
df['log_flow_duration'] = np.log1p(df['Flow Duration'])

# Define bins and human-friendly labels
bins = [0, 5, 10, 13, 16, np.inf]
labels = ['Short (1-10s)', 'Medium (11-100s)', 'Long (101-1000s)', 'Very Long (1001-10000s)', 'Extreme (>10,000s)']

# Categorize the flow durations based on the bins
df['Flow Duration Category'] = pd.cut(df['log_flow_duration'], bins=bins, labels=labels)

# Count how many flows fall into each category
category_counts = df['Flow Duration Category'].value_counts().sort_index()

# Create a DataFrame to enable `hue` mapping
category_df = pd.DataFrame({
    'Category': category_counts.index,
    'Count': category_counts.values
})

# Plotting
plt.figure(figsize=(12, 8))
sns.set_style("whitegrid")

# Histogram of log-transformed flow durations
plt.subplot(2, 1, 1)
sns.histplot(df['log_flow_duration'], bins=50, kde=True, color='steelblue')
plt.title('Log-Transformed Flow Duration Distribution')
plt.xlabel('log(Flow Duration + 1)')
plt.ylabel('Frequency')

# Bar plot of Flow Duration Category Counts with hue
plt.subplot(2, 1, 2)
sns.barplot(data=category_df,
            x='Category',
            y='Count',
            hue='Category',       # <- this satisfies the new Seaborn rule
            palette='viridis',
            legend=False)         # <- disables redundant legend

plt.title('Flow Duration Category Counts')
plt.xlabel('Category')
plt.ylabel('Number of Flows')

plt.tight_layout()
plt.show()

"""Question 3: How Long Do These Attacks Last?

We explore the duration of attack flows to assess severity and stealth.

Charts:

Log-transformed Flow Duration Distribution – Normalizes duration scale.

Flow Duration by Attack Type (Box Plot) – Compares typical durations across attack categories.

Flow Duration Categories (Count Plot) – Segments flows into quick vs long-lived.

Insight: Helps identify persistent threats and potential DoS or stealth behavior.


Based on the results above for Data Distribution;



1.   Most traffic is tiny. Almost every flow lasts only a shorttime, carries only a few packets, and moves very little data. That’s your everyday, harmless browsing and emailing.

2.   A few flows are huge. Those few spikes are the big file dumps, denial-of-service blasts, or sneaky long-running intrusions. They’re rare but important to spot.

"""

#Traffic Volume by Attack Type
# Group by Attack Type and sum traffic
traffic_by_attack = df.groupby('Attack Type')[['Tot Fwd Pkts', 'Tot Bwd Pkts']].sum()

traffic_by_attack.plot(
    kind='bar',
    stacked=True,
    figsize=(10, 6),
    colormap='viridis'
)
plt.title('Traffic Volume by Attack Type (Forward and Backward Packets)')
plt.xlabel('Attack Type')
plt.ylabel('Total Packets')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Step 1: Select numerical columns
numerical_columns = df.select_dtypes(include=['number']).columns
correlation_matrix = df[numerical_columns].corr()

# Step 2: Plot heatmap WITHOUT annotations (no numbers!)
plt.figure(figsize=(14, 10))
sns.heatmap(correlation_matrix,
            cmap='coolwarm',
            annot=False,         # <--- THIS removes all the cluttered numbers
            linewidths=0.5,
            cbar_kws={'shrink': 0.75})

plt.title('Correlation Matrix of Numerical Features', fontsize=16)
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.tight_layout()

# Step 3: Save the clean visual
plt.savefig('correlation_heatmap_cleanstyle.png', dpi=300)
plt.show()

# Step 1: Define a curated list of meaningful numeric features (example subset)
selected_features = [
    'Flow Duration', 'Tot Fwd Pkts', 'Tot Bwd Pkts',
    'TotLen Fwd Pkts', 'TotLen Bwd Pkts',
    'Fwd Pkt Len Max', 'Fwd Pkt Len Mean', 'Fwd Pkt Len Std',
    'Bwd Pkt Len Mean', 'Flow Byts/s', 'Flow Pkts/s',
    'Flow IAT Mean', 'Flow IAT Max'
]

# Step 2: Compute the correlation matrix
correlation_matrix = df[selected_features].corr()

# Step 3: Create the heatmap that looks like your shared image
plt.figure(figsize=(12, 10))  # Adjust size to avoid cramping
sns.heatmap(correlation_matrix,
            annot=True,              # Show correlation values
            fmt='.2f',               # Format to 2 decimal places
            cmap='coolwarm',         # Blue to red gradient
            linewidths=0.5,
            linecolor='grey',
            square=False,            # Allow rectangular cells
            cbar_kws={"shrink": 0.8})  # Shrink color bar for better fit

# Formatting
plt.xticks(rotation=45, ha='right')
plt.yticks(rotation=0)
plt.title('Correlation Matrix of Selected Numerical Features', fontsize=14)
plt.tight_layout()

"""Question: Which features are correlated?

Why it matters: Guides feature selection for modeling, and surfaces hidden patterns.

“Tot Fwd Pkts” and “TotLen Fwd Pkts” have a correlation of 0.70, showing that as the total number of forward packets increases, the total length of those packets also tends to increase.

“Tot Bwd Pkts” and “TotLen Bwd Pkts” have a very high correlation of 0.84, meaning the same relationship exists for backward packets.

Features related to packet lengths within the same direction (like “Fwd Pkt Len Max” and “Fwd Pkt Len Mean” at 0.88, or “Bwd Pkt Len Max” and “Bwd Pkt Len Mean” at 0.77) are strongly correlated, so higher maximum lengths often mean higher average lengths.

Section 3: Static Visualization Analysis


1.   Most Targeted Destination Ports
2.   Flow Duration by Attack Type
3.   Protocol Usage Across Attack Types
4.   Attack Type vs. Destination Port
5.   Average Packet Size by Attack Type
6.   Flags Used in Attacks
7.   Traffic Volume by Attack Type
"""

# Count connections per port and prepare DataFrame
top_ports = df['Dst Port'].value_counts().head(10)
ports_df = pd.DataFrame({
    'Port': top_ports.index.astype(str),
    'Count': top_ports.values
})

# Plotting with correct hue
plt.figure(figsize=(8, 5))
sns.barplot(
    data=ports_df,
    x='Count',
    y='Port',
    hue='Port',          # This satisfies the future Seaborn palette rule
    palette='mako',
    legend=False         # Hides redundant legend
)
plt.title('Top 10 Targeted Destination Ports')
plt.xlabel('Number of Connections')
plt.ylabel('Destination Port')
plt.tight_layout()
plt.show()

"""

---

"""

# Flow Duration by Attack Type
# Box Plot (with log scale on Y) showing how flow durations differ across attack types

plt.figure(figsize=(10, 6))
sns.boxplot(
    x='Attack Type',
    y='Flow Duration',
    data=df,
    hue='Attack Type',      # ✅ add hue
    palette='Set3',         # ✅ keep your color scheme
    dodge=False             # ✅ avoid side-by-side boxplots since hue and x are same
)
plt.yscale('log')
plt.xticks(rotation=45, ha='right')
plt.title('Flow Duration by Attack Type (log scale)')
plt.ylabel('Flow Duration (µs, log scale)')
plt.xlabel('Attack Type')

plt.tight_layout()
plt.show()

"""---

---
"""

# Attack Type vs. Destination Port
# Stacked Bar Chart showing, for the top 5 ports, how many flows of each attack type go to each port.
# Prepare a pivot for top 5 ports
top5 = df['Dst Port'].value_counts().head(5).index
pivot = (df[df['Dst Port'].isin(top5)]
         .groupby(['Dst Port','Attack Type'])
         .size().unstack(fill_value=0))

pivot.plot(
    kind='bar',
    stacked=True,
    figsize=(10,6),
    colormap='tab20'
)
plt.title('Attack Type Distribution for Top 5 Destination Ports')
plt.xlabel('Destination Port')
plt.ylabel('Number of Flows')
plt.xticks(rotation=0)
plt.legend(title='Attack Type', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""Question: Which attacks target which ports?

Why it matters: Connects attack type to services.
"""

# Average Packet Size by Attack Type
# Lollipop Chart of the average Pkt Size Avg per attack type.
# Calculate averages
avg_pkt = df.groupby('Attack Type')['Pkt Size Avg'].mean().sort_values()

plt.figure(figsize=(8, 5))
plt.hlines(
    y=avg_pkt.index,
    xmin=0,
    xmax=avg_pkt.values,
    color='gray',
    alpha=0.7,
    linewidth=2
)
plt.plot(
    avg_pkt.values,
    avg_pkt.index,
    'o',
    color='teal'
)
plt.title('Average Packet Size by Attack Type')
plt.xlabel('Average Packet Size (bytes)')
plt.ylabel('Attack Type')
plt.tight_layout()
plt.show()

"""Question: Which attacks send the biggest or smallest packets on average?

Why it matters: Helps distinguish attack styles.
"""

# Count the usage of each flag
flag_counts = df[['FIN Flag Cnt', 'SYN Flag Cnt', 'RST Flag Cnt', 'PSH Flag Cnt',
                  'ACK Flag Cnt', 'URG Flag Cnt', 'CWE Flag Count', 'ECE Flag Cnt']].sum()

plt.figure(figsize=(10, 6))

# Update the code to avoid FutureWarning
sns.barplot(x=flag_counts.index, y=flag_counts.values, palette='Blues', hue=flag_counts.index)
plt.title('Flag Usage in Attacks')
plt.xlabel('Flag')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

"""Flags Used in Attacks

Bar Chart to visualize the frequency of different flags used in packets. This can help identify attack characteristics based on the flags set in the packets.

Traffic Volume by Attack Type

Stacked Bar Chart showing the total number of packets or bytes per attack type. This will allow you to see which attacks generate the most traffic.

Section 4: Interactive Visualization Dashboard

This section will focus on interactive visualizations that allow deeper exploration and filtering of the data. These dashboards enable users to interact with the data to uncover more granular insights.
"""

fig = px.box(df, x='Attack Type', y='Pkt Len Mean', color='Attack Type',
             title='Packet Length Distribution by Attack Type')
fig.show()

"""Question: How do packet sizes vary per attack type?

Why it matters: Could indicate flooding (large packets) or probing (tiny packets).
"""

import pandas as pd
import plotly.graph_objects as go

# Filter top 10 destination ports
top_ports = df['Dst Port'].value_counts().head(10).index
filtered_df = df[df['Dst Port'].isin(top_ports)].copy()  # Ensure filtered_df is a copy

# Ensure 'Attack Type' column exists, if not, we'll handle gracefully by setting it to 'Other'
if 'Attack Type' not in filtered_df.columns:
    filtered_df['Attack Type'] = 'Other'  # Add 'Attack Type' column with 'Other' as default value

# Replace NaNs in 'Attack Type' for safe mapping
filtered_df['Attack Type'] = filtered_df['Attack Type'].fillna('Other')

# Group data by port and attack type
grouped = filtered_df.groupby(['Dst Port', 'Attack Type']).size().reset_index(name='count')
grouped['Dst Port'] = grouped['Dst Port'].astype(str)

# Create label list and mapping
ports = grouped['Dst Port'].unique().tolist()
attacks = grouped['Attack Type'].unique().tolist()
labels = ports + attacks
label_map = {label: i for i, label in enumerate(labels)}

# Color palette (you can customize further)
color_palette = {
    'DDoS': 'rgba(255,0,0,0.6)',
    'PortScan': 'rgba(255,165,0,0.6)',
    'BruteForce': 'rgba(0,128,0,0.6)',
    'Infiltration': 'rgba(0,0,255,0.6)',
    'Bot': 'rgba(75,0,130,0.6)',
    'Web Attack': 'rgba(255,20,147,0.6)',
    'Heartbleed': 'rgba(128,0,0,0.6)',
    'SQL Injection': 'rgba(138,43,226,0.6)',
    'FTP-Patator': 'rgba(0,206,209,0.6)',
    'SSH-Patator': 'rgba(255,140,0,0.6)',
    'Other': 'rgba(169,169,169,0.6)'
}

# Map sources, targets, values
sources = grouped['Dst Port'].map(label_map)
targets = grouped['Attack Type'].map(label_map)
values = grouped['count']
link_colors = grouped['Attack Type'].map(lambda x: color_palette.get(x, 'rgba(100,100,100,0.6)')).tolist()

# Create Sankey Diagram
fig = go.Figure(data=[go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        line=dict(color="black", width=0.5),
        label=labels,
        color="lightblue"
    ),
    link=dict(
        source=sources,
        target=targets,
        value=values,
        color=link_colors
    )
)])

fig.update_layout(title_text="Sankey Diagram: Top 10 Targeted Ports → Attack Types", font_size=12)
fig.show()

"""Question:

Which attack types are associated with the most frequently targeted destination ports?

Why it matters:

This diagram uncovers relationships between specific attack types and the ports they target, which can:

Help network defenders monitor or block critical ports.

Reveal attacker preferences and strategies (e.g., brute force on port 22 for SSH, or DDoS on port 80 for HTTP).

Suggest which services/systems are most at risk.
"""

# Group and count how many times each Dst Port is used per Protocol
port_usage = df.groupby(['Protocol', 'Dst Port']).size().reset_index(name='Count')

# Sort the entire DataFrame by 'Count' within each 'Protocol' group
port_usage = port_usage.sort_values(by=['Protocol', 'Count'], ascending=[True, False])

# For each protocol, get the top 10 destination ports
top_ports_per_protocol = port_usage.groupby('Protocol').head(10).reset_index(drop=True)

# Create the bar plot
plt.figure(figsize=(8, 4))
sns.barplot(data=top_ports_per_protocol, x='Dst Port', y='Count', hue='Protocol')
plt.title("Top Destination Ports per Protocol")
plt.xlabel("Destination Port")
plt.ylabel("Flow Count")
plt.legend(title="Protocol")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()